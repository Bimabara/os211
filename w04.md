---
layout: "layout"
permalink: /W04/
---

# Top 10 List of Week 04

Hello, this is my top 10 list of Week 04! Minggu-minggu sebelumnya ialah minggu yang tangguh, kita membahas tentang File Systems dan bagaimana struktur File secara umum. Materi minggu ini ialah Main Memory, kalau menurut buku Silberschatz. Namun tertulis *Topic* pada slide ialah Addresing, Shared Lib, dan Pointer. Nah, berikut ialah daftar dari beberapa link yang bagus menurut saya untuk minggu ini. üòÅ

## 1. [Dynamic Memory Allocation in C using malloc(), calloc(), free() and realloc() (Article)](https://www.geeksforgeeks.org/dynamic-memory-allocation-in-c-using-malloc-calloc-free-and-realloc/)

Array is like the most primitive and the "Proto" of all data structures, it stores basically list of any elements. Well, C **Dynamic Memory Allocation** can be defined as a procedure in which the size of a data structure (like Array) is changed during the runtime. C provides some functions to achieve these tasks. There are 4 library functions provided by C defined under **\<stdlib.h\>** header file to facilitate dynamic memory allocation in C programming. They are ```malloc()``` , ```calloc()``` , ```free()``` , ```realloc() ```. I really recommend you to at least understand only this one article out of others C array stuffs out there! It's really interesting and rewarding if you understand how C works, moreover on this dynamic memory allocation topic!!! üçßüçß

## 2. [Cheat Engine (App + Article) a.k.a Read/Write Other Process' Memory](https://www.cheatengine.org/index.php)

OK. Who never uses **cheat engine**? It's a legend app every late 90's and 2000's kids use to **cheat on many singleplayer games.** First things first, what is interesting about it, it's open source, check the [Github Repository](https://github.com/cheat-engine/cheat-engine/) here. Second, it works by reading process memory and writing process memory. There is a dynamically linked library, called the `kernel32.dll` in Windows that is used by **most applications that change memory of other applications or communicate between two processes.** More on it is in the [blog post here](https://nullprogram.com/blog/2016/09/03/). What things being more could about is, Cheat Engine actually works based on a **debugging API** üêúüêõ! But of course it's a bit different story for Linux-Based Distribution and Mac! So yeah, check the blog post as well!

## 3. [Compiling, assembling, and linking (Video + Forum Discussion)](https://www.youtube.com/watch?v=N2y6csonII4)

So, beyond an assembler turning a source into an object binary file, there's actually a *linker* that makes ca program executable. So, you might ask, [What do linkers do?](https://stackoverflow.com/questions/3322911/what-do-linkers-do) To understand it, let's say you have a hello world program, consists of a line `printf("Hello Venti!\n");`  when it is compiled, it simply puts only a reference to the `printf` function, and then the linker will resolve this reference. **It "copies" all the necessary stuffs and references to create a single executable.** It's interesting, knowing that programs is actually not that simple and turns out they actually being heavily optimized by the compiler and operating systems ü§°!

## 4. []()

Bluhbluh

## 5. []()

Bluhbluh

## 6. []()

Bluhbluh

## 7. [Make File (Colored Documentations + Forum)](https://makefiletutorial.com/)

So, make file is essentially a script that lets you `make file`, usually it consists of some several commands to let you compile something or just **arrange some things into a/some file(s)**.  [what is the difference between a makefile and a shell script?](https://stackoverflow.com/questions/3798562/why-use-make-over-a-shell-script) The answer is: It's easier, and makefile is dedicated for it. There are even topological features which lets you save a progress if it's already been done, or lets you run some different flags when making those files üìÅ. It's interesting because. Well, now you can understand what makefile(s) files are in our Demos Mr. RMS provided üòäüòä.

## 8. [The difference between char* and char[]](https://stackoverflow.com/questions/25653034/the-difference-between-char-and-char)

**This is by far the most duplicated questions I personally have seen on stack overflow,** the table provided itself basically explains how this thing works. **So basically when you declare a string with the first way notation, it will place the string in a read only parts of the memory.** It is immutable, and will return a pointer to that. While the other way around, you can also store it as an array of characters! **C is truly amazing**, that's why I think you should read it and it's interesting üòÆüòÆ!  [Reference 1](https://stackoverflow.com/questions/10186765/what-is-the-difference-between-char-array-and-char-pointer-in-c/), [Reference 2](https://stackoverflow.com/questions/1704407/what-is-the-difference-between-char-s-and-char-s/), [Reference 3](https://stackoverflow.com/questions/16021454/difference-between-declared-string-and-allocated-string).

```c
Example:                       Allocation Type:     Read/Write:    Storage Location:   Memory Used (Bytes):
===========================================================================================================
const char* str = "Stack";     Static               Read-only      Code segment        6 (5 chars plus '\0')
char* str = "Stack";           Static               Read-only      Code segment        6 (5 chars plus '\0')
char* str = malloc(...);       Dynamic              Read-write     Heap                Amount passed to malloc
char str[] = "Stack";          Static               Read-write     Stack               6 (5 chars plus '\0')
char strGlobal[10] = "Global"; Static               Read-write     Data Segment (R/W)  10
```

## 9. []()

Bluhbluh

## 10. []()

Bluhbluh

That's all Week 4 from me. I'll start doing Week 5 as soon as possible!

Peace out!
