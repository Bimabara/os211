---
layout: "layout"
permalink: /W06/
---

# Top 10 List of Week 06

Hello, this is my top 10 list of Week 06!

## 1. [The Layman's Guide to Linux: Daemons & Init Systems (10' Video)](https://www.youtube.com/watch?v=ydg9KZCCPE0)

Daemon is a background process that can't be touched by the users. They communicate through history and log files. When system daemons can't be started the kernel panic will show. The init is like the ancestor of all processes as it starts before others, and used as an initializaiton when booting happens ğŸ’». It's also the last being closed when shutdown happens ğŸ˜ª. In linux, the most popular init system is SystemD. For more good explanations, you can also watch:

- [Linux Init Systems Compared! (SystemD, OpenRC, Runit)](https://www.youtube.com/watch?v=k1Wh8sWR8v0)
- [Linux - Start, Stop, Restart Services (Systemd, systemctl, service, init.d )](https://www.youtube.com/watch?v=8JqxRLHGalI)
- [Why "systemd"?](https://www.youtube.com/watch?v=KftuGM_ylKg)

**Interesting Reason:** My teaching assistant talked about the daemon, about how a daemon should have its parent killed ğŸ’€, but then I asked about whether it's an orphan or not? Turns out it will be taken over by the init systems. So, by watching the video you will understand how it works. The video will summarize all important concepts by talking about Daemons and the Init Systems.

## 2. [Understanding process creation in operating system with fork, exec and wait system calls (10' Articles)](http://shivammitra.com/operating%20system/fork-exec-wait-in-operating-system/)

**Interesting Reason:** You'll learn about how forking, exec, and process creation in depth, this will improve your understanding and the explanation is easy to understand ğŸ‘ğŸ‘ğŸ‘! Really good 7-15 minutes read with code you can compile directly ğŸŒ ğŸŒ 

## 3. [Multithreading Code - Computerphile (15' Video)](https://www.youtube.com/watch?v=7ENFeb-J75k)

In Linux, Thread can be seen as a task, in a program, some threads can cause a problem when computing something. When we do a `a = a + i` command, essentially there are 3 commands being done, that is loading, adding, and storing back to a register. When threading is done, those processes can collide and data can get lost. So, to handle it we can use stuffs called mutexes ğŸ˜ŠğŸ˜Š.

**Interesting Reason:** The visual effect from computerphile is top notch! You can't let that eye out of that video box! Multithreading is coool ğŸ˜ğŸ˜ğŸ˜!!

## 4. [Why does a program with fork() sometimes print its output multiple times? (5' Forum)](https://unix.stackexchange.com/questions/447898/why-does-a-program-with-fork-sometimes-print-its-output-multiple-times)

**Interesting Reason:** You'll learn about how buffers in C works and how flush works, the concept is important, moreover it's interesting because you'll learn it from a case! ğŸ“š

## 5. [WTF is a Thread](https://www.youtube.com/watch?v=WYW_zRF-y-I)

Thread is something that 

**Interesting Reason:** Very nice and clear explanation of Thread!

## 6. [All You Need To Know About Processes in Linux [Comprehensive Guide] (3' Article)](https://www.tecmint.com/linux-process-management/)

**Interesting Reason:** This is like the cheatsheet if you want to mess with processes in Linux! ğŸ’» There are lots of command you can type directly from your own terminal and can try for yourself! Well, if you someday in the future will work using Linux, this must be important concepts to you ğŸ˜Š!

## 7. [What is Hyper Threading Technology as Fast As Possible (5' Video)](https://www.youtube.com/watch?v=wnS50lJicXc)

You can see threading as like eating a food, when you eat with two hands, you can acquire things faster âœ‹. But you have to imagine the mouth is like the processor, it has to process something and wait till it's done than the other hand can run as well. Our hand can be slow so while our hand is fetching another food, other hands can be helped to eat ğŸ˜‚. When there are multiprocessors, we can see it as other people eat the food with us ğŸ.

**Interesting Reason:** Good analogy and easy explanation of multi-processing, concurrency and threading, very short yet clear video ğŸ˜!!

## 8. [Process 101 (20' Walkthrough Blog)](https://calvinkam.github.io/csci3150-process/index.html)

**Interesting Reason:** 

## 9. [how does execlp() system call work?](https://stackoverflow.com/questions/25992622/how-does-execlp-system-call-work)

**Interesting Reason:** 

## 10. [fork() can fail: this is important](https://rachelbythebay.com/w/2014/08/19/fork/)

> People seem to know that fork **will return 0** if it's the child and some positive number if you're the parent, that number is the child's pid. They sock this number away and then use it later. Guess what happens when you don't test for failure? Yep, that's right, you probably treat `-1` (fork's error result) as a pid. Killing "pid -1" is equivalent to **massacring every other process you are permitted to signal.** If you're root, that's probably everything. **You live and init lives, but that's it. Everything else is gone gone gone.**

TL;DR No more killing pid `-1` you should be careful when coding, especially when handling processes, threads, and tasks.

**Interesting Reason:** Another short blog by one of my favorite operating systems blogger, RachelByTheBay. Simple stuffs you should handle when coding. It's really good if you wanna go deep into the C embedding system ğŸ˜.

### Extra

- [What is "the stack"?](http://jvns.ca/blog/2016/02/27/a-few-notes-on-the-stack/) (Cool article explaining about the "stack" in operating systems ğŸ“¦)
- [Process Creation](https://mug896.github.io/bash-shell/commands.html) (Article written in Hangul, you can google translate it, the content is amazing ğŸ˜ğŸ˜ğŸ˜)
- [The Linux init system.](http://pminkov.github.io/blog/the-linux-init-system.html) (Really good blog about the init system ğŸ‘ğŸ‘)
- [RAM/Flash Usage in Embedded C Programs](https://blog.stratifylabs.co/device/2013-10-18-RAM-Flash-Usage-in-Embedded-C-Programs/) (Explains memory segments available in our operating systems)
- [Process and Process Management](https://applied-programming.github.io/Operating-Systems-Notes/2-Process-Management/) (Good read and visualization on the memory)

That's all Week 6 from me. I'll start doing Week 7 as soon as possible!

Peace out!
